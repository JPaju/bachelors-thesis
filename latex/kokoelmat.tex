\chapter{Kokoelmat} \label{Kokoelmat}
Tutkimuksen kohteena on Scalan standardikirjaston kokoelmat versiosta 2.8 versioon 2.12. Standardikirjastossa on toteutus useimmille yleisimmille kokoelmaluokille kuten taulukoille, listoille, joukoille(\code{Set}) ja assosiaatiotauluille(\code{Map}). Scalan kokoelmaluokat ovat paketissa \code{scala.collection}. Muuttumattomat kokoelmat ovat alipaketissa \code{immutable} ja muuttuvat alipaketissa \code{mutable}.
\cite{scalaCollections}

Muuttumattoman kokoelman sisältämät alkiot eivät voi muuttua alustamisen jälkeen. Tämä tarkoittaa, ettei alkioiden lisääminen, poistaminen tai uudelleenjärjestäminen ole mahdollista. Kokoelman muuttamista muistuttavat operaatiot, kuten \code{map}, \code{reverse}, \\\code{fold} ja kokoelmien yhdistäminen, palauttavat aina uuden kokoelman jättäen alkuperäisen kokoelman ennalleen. Käytännössä kuitenkaan aina ei kaikkia muuttumattoman kokoelman alkioita ei tarvitse kopioida, vaan tietorakenteet pyrkivät käyttämään hyväkseen rakenteellista jakamista parantaakseen suorituskykyä ja optimoidakseen muistinkäyttöä. Muuttuvissa kokoelmissa on nimensä mukaisesti mahdollista vaihtaa alkioiden järjestystä, lisätä ja poistaa alkioita kokoelmasta luomatta uutta kokoelmaa.
\cite{scalaCollections}
\cite[Luku 22]{prorgrammingInScala3rd}

Kokoelmaluokat noudattavat piirreluokkien määrittelemää hierarkiaa, joka on paketissa \code{scala.collection}. Hierarkia on sama sekä muuttumattomille että muuttuville kokoelmille. Ylimpänä hierarkiassa on \code{Traverable}-piirreluokka, jolla on yksi välitön aliluokka, \code{Iterable}. \code{Iterable}:lla on kolme välitöntä aliluokkaa \code{Seq}, \code{Set} ja \code{Map}, jotka edustavat järjestyksellisiä kokoelmia, joukkoja ja assosiaatiotauluja. Kuvassa \ref{kokoelmahierarkia} näytetään lisäksi vielä muutama aliluokka.
\cite{scalaCollections}
\begin{figure}[h]
    \centering\input{kuvat/collections_hierarchy.tex}
    \caption{Kokoelmien hierarkia}\label{kokoelmahierarkia}
\end{figure}


\section{Järjestykselliset kokoelmat}
\todo{Etsi parempi ilmaus järjestykselliselle}
Suorituskykyvertailuun valittiin muuttumattomista kokoelmista \code{List}, joka tyypillinen rekursiivinen linkitetty rakenne funktionaaliessa ohjelmoinnissa, ja \code{Vector}, jossa alkion haku indeksin mukaan on tehokkaampaa. Muuttuvista kokoelmista valittiin \code{Array}, joka on kiinteän kokoinen taulukko, \code{ArrayBuffer}, joka on dynaamisesti kasvava taulukko ja \code{ListBuffer}, joka on dynaamisesti kasvava linkitetty rakenne. Kaikki kyseiset muuttuvat tietorakenteet ovat tyypillisiä olio-ohjelmoinnissa käytettyjä tietorakenteita.

\code{List} on abstrakti luokka, joka kuvaa yhteen suuntaan linkitettyä rekursiivista muuttumatonta listaa, jolla on kaksi konkreettista toteutusta: \code{::} ja \code{Nil}. Epätyhjää listaa kuvaavassa luokassa \code{::} on kaksi jäsentä: alkio, jota kutsutaan listan \textit{pääksi}, ja \textit{häntä} joka kuvaa listan muita alkioita. Tyhjää listaa ja samalla listan loppumista kuvaa singleton-olio \code{Nil}. Esimerkiksi luvut 1 ja 2 sisältävä lista voidaan ilmaista näin: \code{1 :: 2 :: Nil}. Listan \code{head}-ja \code{tail}-operaatiot sekä listan alkuun lisääminen tapahtuvat vakioajassa. Aikakompleksisuus alkion hakemiselle indeksin perusteella on lineaarinen.
\cite{scalaAPI}
\cite{scalaCollections}

\code{Vector} on taulukon ominaisuuksia jäljittelevä muuttumaton tietorakenne, joka on toteutettu puurakenteena, jonka solmut ovat korkeintaan 32-alkioisia taulukoita. Lehtisolmujen taulukot sisältävät vektorin varsinaisia alkioita, ja muut solmut sisältävät alemman tason taulukoita. Jos esimerkiksi alustetaan uusi 70-alkioinen vektori, on se kolmen taulukon puu, jossa juurisolmuna olevalla taulukolla on kolme lapsitaulukkoa, joista kahdessa on 32 alkiota ja yhdessä 6 alkiota. Tämä mahdollistaa taulukoiden rakenteellisen jakamisen eri vektori-instanssien kesken, mikä vähentää kopioimista ja muistinkäyttöä. Satunnaisten haku-, muokkaus- ja poisto-operaatioiden aikakompleksisuus on log(32, N), eli operaatioiden voidaan ajatella tapahtuvan lähes vakioajassa.
\cite{scalaCollections}
\cite[Luku 4]{highPerformanceProgramming}

\code{Array} on Scalassa erityinen kokoelma, joka mahdollistaa primitiivityyppisten, viittaustyyppisten ja geneeristen alkioiden tallentamisen. Primitiivityyppisiä alkioita käsitellään ilman alkioiden käärimistä olioiksi. Esimerkiksi kokonaislukuja sisältävä \\\code{Array[Int]} kääntyy Javan \code{int[]}-taulukoksi. Kuten Javassa, taulukon koko ei voi muuttua alustamisen jälkeen. Verrattuna Javan taulukoihin \code{Array} tarjoaa kuitenkin huomattavasti enemmän operaatioita. Haku-ja muokkausoperaatiot tapahtuvat vakioajassa. Häntäoperaatio vie kuitenkin lineaarisen ajan, sillä jokainen alkio, poislukien ensimmäinen, joudutaan kopioimaan uuteen taulukkoon.
\cite{scalaCollections}

\code{ArrayBuffer} on dynaamisesti kasvava listarakenne, joka käyttää alkioiden tallentamiseen taulukkoa. Tästä johtuen useimmat operaatiot vastaavat aikakompleksisuudeltaan \code{Array}:ta. Lisäksi \code{ArrayBuffer} mahdollistaa alkion lisäämisen taulukon alkuun, loppuun sekä keskelle. Alkuun ja keskelle lisäämisen aikakompleksisuus on lineaarinen. Muut operaatiot tapahtuvat pääasiassa vakioajassa, poislukien täyteen taulukkoon lisääminen, joka vie lineaarisen ajan.
\cite{scalaCollections}

\code{ListBuffer} on dynaamisesti kasvava muuttuva kokoelma joka on toteutettu linkitettynä rakenteena. Poiketen \code{List}:stä, \code{ListBuffer} mahdollistaa alkioiden lisäämisen rakenteen alkuun ja loppuun vakioajassa. Satunnaisen alkion haku-ja muokkausoperaatiot sekä rakenteen keskelle lisääminen ovat aikakompleksisuudeltaan lineaarisia. Myös häntäoperaatio vie lineaarisen ajan, sillä kaikki hännän alkiot täytyy kopioida uuteen tietorakenteeseen.   
\cite{scalaCollections}


\section{Joukot ja assosiaatiotaulut}
\todo{Tarkastellaanko ollenkaan?}


\section{Suorituskykyvertailut}

Tutkielmassa on käytetty kokoelmien suorituskykymittauksia kahdesta eri lähteestä: Li Haoyi:n\cite{haoyiBenchmark} ja Toby Hobsonin\cite{hobsonBenchmark} mittauksista. Haoyin mittauksissa mitataan aikaa, jonka operaatioiden suorittaminen vie, eli pienempi arvo tarkoittaa parempaa suorituskykyä. Hobsonin mittauksissa tarkastellaan operaatioiden määrää sekunnissa, jolloin suuri luku takoirttaa parempaa suorituskykyä. Hayoin mittauksissa suorituskykyä on mitattu eri kokoisilla kokoelmilla. Kaavioihin on valittu kyseisen operaation kannalta mielekkäät koot kokoelmille.

Järjestyksellisten kokoelmien tapauksessa kiinnostuksen kohteena on yleisimpien operaatioiden suorituskyky: kokoelman luominen, iterointi, alkion satunnainen haku sekä lisääminen ja häntäoperaatio. 


\subsection{Iterointi}
Iteroinnissa kokoelman jokainen alkio käydään läpi. Lähteenä käytettävissä suorituskykymittauksissa ei tutkittu rinnakkaisten kokoelmien suorituskykyä, joten iterointi tapahtui järjestyksessä. Haoyin mittauksissa \code{Array}:n iteroiminen \code{while}-silmukalla sekä \\\code{ArrayBuffer}:n iteroiminen tapahtui mittaamattoman lyhyessä tai jopa negatiivisessa ajassa, joten on kyseisiä mittauksia ei otettu huomioon. Kaaviosta \ref{iterointi_kaavio} voidaan huomata, että suorituskyvyissä ei ollut suuria eroavaisuuksia, paitsi Hobsonin mittauksissa \code{ArrayBuffer} oli 3-4 kertaa muita kokoelmia nopeampi. Haoyin mittauksissa merkittävää eroa ei ollut, vaikkakin \code{Array} oli hieman muita nopeampi.

\begin{figure}[h]
    \centering
    \input{kaaviot/kokoelmat/iterointi_kaavio.tex}
    \caption{Iterointi}\label{iterointi_kaavio}
\end{figure}


\subsection{Satunnainen haku}
Nimensä mukaan satunnainen haku tarkoittaa alkion hakemista kokoelmasta satunnaisen indeksin perusteella. Linkitetyissä rakenteissa haku vaatii alkioiden käymistä läpi peräkkäin kunnes haettu indeksi saavutetaan. Taulukkopohjaisissa tietorakenteissa vastaavaa rajoitetta ei ole, vaan alkion muistiosoite voidaan laskea suoraan indeksin perusteella. Tämän perusteella on perusteltua olettaa taulukkojen olevan huomattavasti linkitettyjä rakenteita suorituskykyisempiä.

Hobsonin mittaukset kaaviossa \ref{satunnainenHaku_kaavio} tukevat tätä hypoteesia. \code{ListBuffer} sekä \code{List} ovat jopa useita satoja kertoja hitaampia kuin taulukoihin pohjautuvat kokoelmat. Hieman yllättäen \code{ListBuffer} on kuitenkin noin 3,5 kertaa nopeampi kuin \code{List}, vaikka \code{ListBuffer} käyttää sisäisesti alkioiden tallentamiseen \code{List}:iä. Taulukon ominaisuuksia mukaileva \code{Vector} ja \code{Array} olivat suorituskyvyltään lähes identtisiä. \code{ArrayBuffer} oli noin 15\% nopeampi kuin muut taulukkopohjaiset kokoelmat, mikä on hieman yllättävää, sillä sisäisesti alkiot tallennetaan käyttäen \code{Array}:ta.

\begin{figure}[h]
    \centering
    \input{kaaviot/kokoelmat/satunnainenhaku_kaavio.tex}
    \caption{Satunnainen haku}\label{satunnainenHaku_kaavio}
\end{figure}


\subsection{Kokoelman luominen}
Kokoelmia rakennetaan useasti lisäämällä alkioita yksi kerrallaan kokoelmaan. Joskus kokoelma luodaan toisen kokoelman tai kokoelmatyypin alkioista. Taulukkoa (\code{Array}) luotaessa täytyy yleensä päättää miten monen alkion taulukko luodaan. Mikäli täyteen taulukkoon halutaan lisätä alkioita, täytyy luoda uusi suurempi taulukko ja kopioida kaikki alkiot alkuperäisestä taulukosta uuteen taulukkoon ja lisätä uusi alkio uuteen taulukkoon. Taulukon kaikkien alkioiden kopiointi uuteen taulukkoon todennäköisesti huonontaa suorituskykyä huomattavasti.

Hayoin vertailuissa (kaavio \ref{kokoelmanLuominen_kaavio}) on testattu useita tapoja kokoelman luomiseen. \code{Array:+} kuvastaa tilannetta, jossa luodaan kokoelma lisäämällä alkio täyteen taulukkoon. Oletetusti sen suorituskyky on koko vertailun huonoin. \code{Array-prealloc} kuvaa tilannetta, jossa luodaan valmiiksi oikean kokoinen taulukko, ja sen suorituskyky on vertailun paras.

\code{Vector:+} aikakompleksisuuden pitäisi olla lähes vakio \cite{scalaCollections}, mutta mittausten perusteella suorituskyky on varsin heikko. Erityisesti kun luodaan yli 1024 alkion kokoelmia ja sisäiseen puurakenteeseen tulee yksi taso lisää, suorituskyky heikkenee merkittävästi. Suorituskykyisempi tapa luoda \code{Vector} on luoda toinen kokoelma ja kutsua sen \code{toVector}-metodia. Haoyin mittausten \code{Array.toVector} on tilanne, jossa luodaan \code{Array} pre-alloc-tyylisesti ja luodaan sen pohjalta \code{Vector}. Suorituskyky on huomattavasti parempi kuin lisäämällä alkioita yksi kerrallaan.




\begin{figure}[h]
    \centering
    \input{kaaviot/kokoelmat/kokoelman_luominen_kaavio.tex}
    \caption{Kokoelman luominen}\label{kokoelmanLuominen_kaavio}
\end{figure}

\begin{figure}[h]
    \centering
    \input{kaaviot/kokoelmat/append_kaavio.tex}
    \caption{Kokoelman loppuun lisääminen}\label{kokoelmanLoppuunLisaaminen_kaavio}
\end{figure}

\begin{figure}[h]
    \centering
    \input{kaaviot/kokoelmat/tail_kaavio.tex}
    \caption{Häntäoperaatio}\label{hantaoperaatio_kaavio}
\end{figure}
